<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NaPiRE trouble predictor</title>
  <base href="/web/">
  <link rel="stylesheet" href="external/jquery-ui/jquery-ui.css">
  <link rel="stylesheet" href="shared.css">
  <link rel="stylesheet" href="index.css">
  <link rel="shortcut icon" href="./favicon.ico">
  <script src="external/jquery/jquery.js"></script>
  <script src="external/jquery-ui/jquery-ui.js"></script>
  <script>
    params = {
        "connect": [],
        "query": [],
        "evidence": {},
        "inference_method": ""
    };
    old_params = {};
    items = {};
    loading = 0;

    function equals(a, b) {
        let prs = Object.getOwnPropertyNames(a).concat(Object.getOwnPropertyNames(b));
        for (let i = 0; i < prs.length; i++) {
            let pr = prs[i];
            if(!a.hasOwnProperty(pr) || !b.hasOwnProperty(pr)) {
                return false;
            }

            if (a[pr] !== b[pr]) {
                return false;
            }
        }
        return true;
    }

    function post(url, overwrites) {
        if(!overwrites) overwrites = {};
        let query_dict = $.extend({}, params, overwrites);

        return $.ajax(url, {
                "method": "POST",
                "contentType": "application/json",
                "processData": false,
                "data": JSON.stringify(query_dict)
        });
    }

    function update_loading(inc) {
        loading = loading + inc;
        if(loading < 0) loading = 0;

        if(loading == 0) $("#loading_indicator").hide();
        else $("#loading_indicator").show();
    }

    function update_connectivity_view() {
        let connectivity = Object.getOwnPropertyNames(items);
        connectivity.sort();

        //
        // nodes setup
        //

        $("#connectivity_available").empty()

        for(let i of connectivity) {
            $("#connectivity_available").append("<li>" + i + "</li>");
        }

        let nodes_minweight = {};
        for(let i of connectivity) {
            let mw_id = "nodes_min_weight_" + i;
            let mw_val = parseInt($("#" + mw_id).val());

            nodes_minweight[i] = isNaN(mw_val) ? 5 : mw_val;
        }
        params["nodes"] = nodes_minweight;

        $("#connectivity_nodesweight").empty();
        $("#connectivity_nodesnumber").empty();
        for(let i of connectivity) {
            let mw_id = "nodes_min_weight_" + i;
            $("#connectivity_nodesweight").append("<input id=\"" + mw_id + "\" class=\"min_weight\"" +
                " type=\"number\" min=\"0\" value=\"" + nodes_minweight[i] + "\" name=\"" + mw_id + "\"/>");

            $("#" + mw_id).change(function(event) {
                update_items();
            });

            $("#connectivity_nodesnumber").append("<input class=\"min_weight\"" +
                " type=\"number\" disabled value=\"" + items[i].length + "\"/>");
        }

        //
        // edges setup
        //

        let from_keys = [];
        for(let ch of $("#connectivity_from").children()) {
            ch = $(ch)
            from_keys.push(ch.text());
        }

        let to_keys = [];
        for(let ch of $("#connectivity_to").children()) {
            ch = $(ch)
            to_keys.push(ch.text());
        }

        let connect = [];
        for(let i = 0; i < Math.min(from_keys.length, to_keys.length); i++) {
            let mw_id = "edges_min_weight_" + i;
            let mw_val = parseInt($("#" + mw_id).val());

            connect.push( [ from_keys[i], to_keys[i], isNaN(mw_val) ? 9 : mw_val ]);
        }
        params["connect"] = connect;

        $("#connectivity_edgesweight").empty();
        for(let i = 0; i < Math.min(from_keys.length, to_keys.length); i++) {
            let mw_id = "edges_min_weight_" + i;
            $("#connectivity_edgesweight").append("<input id=\"" + mw_id + "\" class=\"min_weight\"" +
                " type=\"number\" min=\"0\" value=\"" + connect[i][2] + "\" name=\"" + mw_id + "\"/>");

            $("#" + mw_id).change(function(event) {
                update_items();
            });
        }
    }

    function update_evidence_params(category_drag) {
        let data = {};

        function update(list, value) {
            list = $(list);

            for(let item of list.children()) {
                item = $(item).text();
                if(items[item]) {
                    for(let subitem of items[item]) {
                        if(!data[subitem]) { // do not overwrite if already present individually
                            data[subitem] = value;
                        }
                    }
                } else {
                    data[item] = value; // do overwrite if already present by category
                }
            }
        }

        update("#evidence_true", true);
        update("#evidence_false", false);
        update("#evidence_output", null);

        params["evidence"] = {};
        params["query"] = [];
        for(let item in data) {
            if(data[item] === null) {
                params["query"].push(item);
            } else {
                params["evidence"][item] = data[item];
            }
        }
    }

    function update_evidence_view() {
        let evidence = [];
        for(let type in items) {
            if(items[type].length > 0) {
                evidence.push(type);
                evidence.push.apply(evidence, items[type]);
            }
        }

        function update(list) {
            list = $(list);

            let contained = []
            for(let ch of list.children()) {
                ch = $(ch);
                match = false;
                for(let e of evidence) {
                    match = match || (ch.text() === e);
                }

                if(!match) {
                    ch.remove();
                } else {
                    contained.push(ch.text());
                }
            }

            return contained
        }

        let contained = update("#evidence_false");
        contained = contained.concat(update("#evidence_true"));
        contained = contained.concat(update("#evidence_output"));

        for(let c of contained) {
            let idx = evidence.indexOf(c);
            if(idx >= 0) {
                evidence.splice(idx, 1);
            }
        }

        evidence.sort();
        $("#evidence_unknown").empty();
        for(let e of evidence) {
            $("#evidence_unknown").append("<li>" + e + "</li>");
        }

        update_evidence_params();
    }

    function update_descriptions() {
        post("/descriptions?all_items=true").then(function(descriptions) {
            let types = Object.getOwnPropertyNames(items);
            types.sort();
            $("#codes").empty();

            for(type of types) {
                let codes = items[type];
                codes.sort();
                if(codes.length == 0) {
                    continue;
                }


                let tcells="";
                for(let c of codes) {
                    tcells += "<tr><td class=\"codes-code\">" + c + "</td><td class=\"codes-description\">" + descriptions[c] + "</td></tr>";
                }

                $("#codes").append("<h2>" + type + "</h2><table><thead><th>Code</th><th>Description</th></thead><tbody>" + tcells + "</tbody></table>");
            }
        });
    }

    function update_items(init) {
        if(init) {
            $("#connectivity_to").append("<li>PROBLEMS_CODE</li>");
            $("#connectivity_to").append("<li>EFFECTS_CODE</li>");

            $("#connectivity_from").append("<li>CAUSES_CODE</li>");
            $("#connectivity_from").append("<li>PROBLEMS_CODE</li>");

            $.ajax("/inference").then(function(response) {
                for(let method of response) {
                    $("#inference_method").append("<option value=\"" + method + "\">" + method + "</option>");
                }
            });
        }
        update_connectivity_view()

        post("/items").then(function(response) {
            items = response;

            update_connectivity_view();
            update_evidence_view();
            update_descriptions();

            if(init) {
                setTimeout(update_image);
                setTimeout(update_validations);
                setInterval(update_image, 1000);
                setInterval(update_validations, 3000);
            }
        });
    }

    function update_image() {
        if(!equals(old_params, params)) {
            post("/query?data_url=true")
                .then( function(response) {
                    update_loading(-1);
                    let img = new Image();
                    img.src = response;
                    $("#output_graph").html(img);
                    $("#run_inference").prop("disabled", false);
                }).fail( function(response) {
                    update_loading(-1);
                    $("#output_graph").html(
                        "<p>" + response.statusText + " (" +  response.status + ")<br/>"
                        + response.responseText + "<p>");
                    $("#run_inference").prop("disabled", false);
                });

            params["inference_method"] = "";
            old_params = Object.assign({}, params);
            update_loading(+1);
        }
    }

    function update_validations() {
        return $.ajax("/validations")
            .then( function(response) {
                $("#output_validation").empty();
                if(response.length == 0) {
                    $("#validation_indicator").html("<p>No validations run so far.</p>");
                } else {
                    $("#validation_indicator").html("");
                    let val_queries = 0;
                    for(let validation of response) {
                        $("#output_validation").append(
                              "<li><a href=\"javascript:graph_window = window.open(graph_window_path(" + val_queries +"), '_blank', 'width=700,height=850'); void(0)\">" + validation.query.inference_method + "</a>"
                            + ": " + validation.query.subsample_size + " subjects per subsample, " + validation.query.iterations + " iterations, "
                            + (validation.done ? "" : (validation.steps_done / validation.steps_total * 100).toFixed(2) + "%") + " done.</li>");
                        val_queries++;
                    }
                }
            });
    }

    function graph_window_path(i) {
        return 'graph.html?id=' + (i + 1);
    }

    function run_inference() {
        params["inference_method"] = $("#inference_method").val();
        $("#run_inference").prop("disabled", true);
    }

    function run_validation() {
        $("#run_validation").prop("disabled", true);
        post("/validate", {
            "inference_method": $("#inference_method").val(),
            "subsample_size": $("#validation_subsample_size").val(),
            "iterations": $("#validation_iterations").val()
        }).then( function(response) {
            update_validations().then(function(response) {
                    $("#run_validation").prop("disabled", false);
                }).fail(function(response) {
                    $("#run_validation").prop("disabled", false)
                });
        }).fail(function(response) {
            $("#run_validation").prop("disabled", false)
        });
    }

    $( function() {

    for(let i of [ "#connectivity_from", "#connectivity_to", "#connectivity_available" ]) {
        $(i).sortable({
            connectWith: "ul.connectivity_drop",
            stop: function(event, ui) { update_connectivity_view(); update_items(); },
            revert: 200
        });
    }

    for(let i of [ "#evidence_unknown", "#evidence_true", "#evidence_false", "#evidence_output" ]) {
        $(i).sortable({
            connectWith: "ul.evidence_drop",
            stop: function(event, ui) { update_evidence_params(); },
            revert: 200
        });
    }

    update_items(true);

    });
  </script>
</head>
<body>

<div id="setup">

<h1>Architecture</h1>

<button class="centered_button" type="button" onclick="$('#codes_container').toggle()">Show/hide code descriptions</button>

<table>
<thead>
<th>Available node types</th><th>Filter</th><th>Number</th>
</thead>
<tbody>

<td>
<ul id="connectivity_available" class="connectivity_drop">
</ul>
</td>

<td id="connectivity_nodesweight">
</td>

<td id="connectivity_nodesnumber">
</td>

</tbody>
</thead>

<table>
<thead>
    <th>From</th><th>To</th><th>Filter</th>
</thead>
<tbody>
<tr>
<td>
<ul id="connectivity_from" class="connectivity_drop">
</ul>

<td>
<ul id="connectivity_to" class="connectivity_drop">
</ul>
</td>

<td id="connectivity_edgesweight">
</td>
</tr>
</tbody>
</table>

<h1>Inference</h1>

<div class="settings_container">

<div class="settings_row">
<div class="settings_cell">
<label for="inference_method">Inference method</label>
</div>

<div class="settings_cell">
<select id="inference_method" name="inference_method">
</select>
</div>
</div>

<div class="settings_row">
<div class="settings_cell">
<label for="validation_subsample_size">Validation subsample size</label>
</div>

<div class="settings_cell">
<input id="validation_subsample_size" name="validation_subsample_size" type="number" min="1" value="1"/>
</div>
</div>

<div class="settings_row">
<div class="settings_cell">
<label for="validation_iterations">Validation iterations</label>
</div>

<div class="settings_cell">
<input id="validation_iterations" name="validation_iterations" type="number" min="1" value="1"/>
</div>
</div>

</div>

<div class="button_container">
<button id="run_inference"  type="button" onclick="run_inference()">Start inference</button>
<button id="run_validation" type="button" onclick="run_validation()">Start validation</button>
</div>

<ul id="evidence_unknown" class="evidence_drop">
</ul>

<p class="hint">Hint: if you run out of memory, reduce the number of output variables.</p>

<table>
<thead>
    <th>Absent</th><th>Present</th><th>Output</th>
</thead>
<tbody>
<tr>

<td>
<ul id="evidence_false" class="evidence_drop">
</ul>
</td>

<td>
<ul id="evidence_true" class="evidence_drop">
</ul>
</td>

<td>
<ul id="evidence_output" class="evidence_drop">
</ul>
</td>
</tr>

</tbody>
</table>

</div>

<div id="codes_container" style="display: none">
<h1>Codes</h1>

<div id="codes">
</div>
</div>

<div id="result">

<h1>Graph representation</h1>
<button class="centered_button" onclick="$('#legend').toggle()">Show/hide legend</button>
<img id="legend" style="display: none;" src="../query_legend"></img>

<p id="loading_indicator">Loading...</p>


<div id="output_graph">
</div>

<h1>Validation results</h1>

<div id="validation_indicator"></div>

<ol id="output_validation">

</ol>

</div>

</body>
</html>
